<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ä¸å‹•ç”£åæ”¯è¨ˆç®—æ©Ÿ</title>
<!-- PWA meta tags -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="åæ”¯è¨ˆç®—æ©Ÿ">
<meta name="theme-color" content="#2563EB">
<meta name="description" content="ä¸å‹•ç”£æŠ•è³‡ã®æ¡ˆä»¶åˆ¥åæ”¯è¨ˆç®—æ©Ÿ">
<!-- App icon -->
<link rel="apple-touch-icon" href="icon-192.png">
<link rel="icon" type="image/png" href="icon-192.png">
<!-- Manifest -->
<link rel="manifest" href="manifest.json">
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body, #root { height: 100%; }
body { font-family: 'DM Sans', 'Noto Sans JP', sans-serif; -webkit-tap-highlight-color: transparent; }
input, textarea, button { font-family: inherit; }
/* Safe area for notched iPhones */
@supports (padding: env(safe-area-inset-top)) {
  body { padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); padding-left: env(safe-area-inset-left); padding-right: env(safe-area-inset-right); }
}
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;

// â”€â”€â”€ Math expression parser â”€â”€â”€
function tokenize(expr) {
  const tokens = [];
  let i = 0;
  while (i < expr.length) {
    if (expr[i] === " ") { i++; continue; }
    if ("0123456789.".includes(expr[i])) {
      let num = "";
      while (i < expr.length && "0123456789.".includes(expr[i])) { num += expr[i++]; }
      tokens.push({ type: "num", value: parseFloat(num) });
    } else if ("+-*/".includes(expr[i])) {
      tokens.push({ type: "op", value: expr[i++] });
    } else if (expr[i] === "(") {
      tokens.push({ type: "lparen" }); i++;
    } else if (expr[i] === ")") {
      tokens.push({ type: "rparen" }); i++;
    } else {
      throw new Error("ä¸æ­£ãªæ–‡å­—: " + expr[i]);
    }
  }
  return tokens;
}
function parseExpr(tokens, pos) {
  let [left, p] = parseTerm(tokens, pos);
  while (p < tokens.length && tokens[p].type === "op" && (tokens[p].value === "+" || tokens[p].value === "-")) {
    const op = tokens[p].value; p++;
    let [right, np] = parseTerm(tokens, p); left = op === "+" ? left + right : left - right; p = np;
  }
  return [left, p];
}
function parseTerm(tokens, pos) {
  let [left, p] = parseFactor(tokens, pos);
  while (p < tokens.length && tokens[p].type === "op" && (tokens[p].value === "*" || tokens[p].value === "/")) {
    const op = tokens[p].value; p++;
    let [right, np] = parseFactor(tokens, p); left = op === "*" ? left * right : left / right; p = np;
  }
  return [left, p];
}
function parseFactor(tokens, pos) {
  if (pos >= tokens.length) throw new Error("å¼ãŒä¸å®Œå…¨ã§ã™");
  if (tokens[pos].type === "op" && tokens[pos].value === "-") {
    let [val, p] = parseFactor(tokens, pos + 1); return [-val, p];
  }
  if (tokens[pos].type === "num") return [tokens[pos].value, pos + 1];
  if (tokens[pos].type === "lparen") {
    let [val, p] = parseExpr(tokens, pos + 1);
    if (p >= tokens.length || tokens[p].type !== "rparen") throw new Error("ã‚«ãƒƒã‚³ãŒé–‰ã˜ã¦ã„ã¾ã›ã‚“");
    return [val, p + 1];
  }
  throw new Error("ä¸æ­£ãªå¼ã§ã™");
}
function evaluate(expr) {
  if (!expr.trim()) throw new Error("å¼ãŒç©ºã§ã™");
  const tokens = tokenize(expr);
  const [result, pos] = parseExpr(tokens, 0);
  if (pos !== tokens.length) throw new Error("ä¸æ­£ãªå¼ã§ã™");
  return result;
}
function formatNumber(n) {
  if (Number.isNaN(n) || !Number.isFinite(n)) return "ã‚¨ãƒ©ãƒ¼";
  const fixed = Math.abs(n) < 1e-10 ? 0 : n;
  return new Intl.NumberFormat("ja-JP", { maximumFractionDigits: 4 }).format(fixed);
}
function uid() { return Date.now().toString(36) + Math.random().toString(36).slice(2, 8); }

// â”€â”€â”€ IndexedDB helpers â”€â”€â”€
const DB_NAME = "re-calc-db";
const DB_VERSION = 2;
const CASE_STORE = "cases";
const FILE_STORE = "files";

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(CASE_STORE)) {
        db.createObjectStore(CASE_STORE, { keyPath: "id" });
      }
      if (!db.objectStoreNames.contains(FILE_STORE)) {
        db.createObjectStore(FILE_STORE, { keyPath: "id" });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbGetAll(storeName) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const req = tx.objectStore(storeName).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

async function idbGet(storeName, id) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const req = tx.objectStore(storeName).get(id);
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => reject(req.error);
  });
}

async function idbPut(storeName, item) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).put(item);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function idbDelete(storeName, id) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).delete(id);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

// Load file data on demand (lazy)
async function loadFileData(fileId) {
  try {
    const record = await idbGet(FILE_STORE, fileId);
    return record ? record.dataUrl : null;
  } catch { return null; }
}

// Save file data separately
async function saveFileData(fileId, dataUrl) {
  try { await idbPut(FILE_STORE, { id: fileId, dataUrl }); } catch (e) { console.error("File save error:", e); }
}

// Delete file data
async function deleteFileData(fileId) {
  try { await idbDelete(FILE_STORE, fileId); } catch (e) { console.error("File delete error:", e); }
}

async function loadAllCases() {
  try {
    const cases = await idbGetAll(CASE_STORE);
    if (cases.length > 0) {
      // Migrate: if any file still has dataUrl inline, move to FILE_STORE
      let migrated = false;
      for (const c of cases) {
        if (c.files) {
          for (const f of c.files) {
            if (f.dataUrl) {
              await saveFileData(f.id, f.dataUrl);
              delete f.dataUrl;
              migrated = true;
            }
          }
        }
      }
      if (migrated) { for (const c of cases) await idbPut(CASE_STORE, c); }
      return cases;
    }
    // Migrate from localStorage
    try {
      const idx = JSON.parse(localStorage.getItem("re-calc-index") || "[]");
      if (idx.length > 0) {
        const lsCases = idx.map(meta => {
          const full = JSON.parse(localStorage.getItem("re-calc-case:" + meta.id) || "null");
          return full ? { ...meta, ...full } : { ...meta, memo: "", entries: [], files: [] };
        });
        for (const c of lsCases) {
          if (c.files) {
            for (const f of c.files) {
              if (f.dataUrl) {
                await saveFileData(f.id, f.dataUrl);
                delete f.dataUrl;
              }
            }
          }
          await idbPut(CASE_STORE, c);
        }
        return lsCases;
      }
    } catch {}
    return [];
  } catch { return []; }
}

async function saveCaseData(c) {
  try {
    // Strip dataUrl from files before saving case (should already be stripped, but just in case)
    const cleaned = { ...c, files: (c.files || []).map(f => { const { dataUrl, ...meta } = f; return meta; }) };
    await idbPut(CASE_STORE, cleaned);
  } catch (e) { console.error("Save error:", e); }
}

async function deleteCaseData(id) {
  try { await idbDelete(CASE_STORE, id); } catch (e) { console.error("Delete error:", e); }
}

// Backup: include file data
async function exportBackup(cases) {
  const full = [];
  for (const c of cases) {
    const filesWithData = [];
    for (const f of (c.files || [])) {
      const dataUrl = await loadFileData(f.id);
      filesWithData.push({ ...f, dataUrl: dataUrl || "" });
    }
    full.push({ ...c, files: filesWithData });
  }
  const data = JSON.stringify(full, null, 2);
  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "ä¸å‹•ç”£åæ”¯è¨ˆç®—æ©Ÿ_backup_" + new Date().toISOString().slice(0, 10) + ".json";
  a.click();
  URL.revokeObjectURL(url);
}

// Restore: split file data back out
function importBackup(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const cases = JSON.parse(e.target.result);
        if (!Array.isArray(cases)) throw new Error("ä¸æ­£ãªãƒ‡ãƒ¼ã‚¿");
        for (const c of cases) {
          if (c.files) {
            for (const f of c.files) {
              if (f.dataUrl) {
                await saveFileData(f.id, f.dataUrl);
                delete f.dataUrl;
              }
            }
          }
          await idbPut(CASE_STORE, c);
        }
        resolve(cases);
      } catch (err) { reject(err); }
    };
    reader.onerror = () => reject(reader.error);
    reader.readAsText(file);
  });
}

// â”€â”€â”€ Colors â”€â”€â”€
const C = {
  bg: "#F5F6F8", surface: "#FFFFFF", surface2: "#F0F1F4",
  border: "#D9DCE3", border2: "#C5C9D3",
  accent: "#2563EB", accent2: "#1D4FD7", accentSoft: "rgba(37,99,235,0.08)",
  green: "#16A34A", greenSoft: "rgba(22,163,74,0.08)",
  red: "#DC2626", redSoft: "rgba(220,38,38,0.08)",
  amber: "#D97706", amberSoft: "rgba(217,119,6,0.08)",
  text: "#1A1A1A", text2: "#6B7280", text3: "#9CA3AF",
  white: "#FFFFFF", gray: "#6B7280", grayBg: "#6B7280",
};
const font = "'DM Sans', 'Noto Sans JP', sans-serif";

function useIsMobile(bp = 640) {
  const [m, setM] = useState(window.innerWidth < bp);
  useEffect(() => { const f = () => setM(window.innerWidth < bp); window.addEventListener("resize", f); return () => window.removeEventListener("resize", f); }, []);
  return m;
}

// Touch drag for mobile: long press â†’ slide â†’ release to place
// Uses addEventListener directly for passive:false support
function useTouchDrag(onReorder) {
  const [pickedIdx, setPickedIdx] = useState(null);
  const [overIdx, setOverIdx] = useState(null);
  const itemRefs = useRef([]);
  const longPressTimer = useRef(null);
  const active = useRef(false);
  const stateRef = useRef({ pickedIdx: null, overIdx: null });
  const onReorderRef = useRef(onReorder);
  onReorderRef.current = onReorder;

  useEffect(() => { stateRef.current = { pickedIdx, overIdx }; });

  const setRef = (i, el) => {
    const prev = itemRefs.current[i];
    itemRefs.current[i] = el;
    if (!el || el === prev) return;

    el.addEventListener("touchstart", () => {
      longPressTimer.current = setTimeout(() => {
        active.current = true;
        stateRef.current = { pickedIdx: i, overIdx: i };
        setPickedIdx(i);
        setOverIdx(i);
        document.body.style.overflow = "hidden";
        if (navigator.vibrate) navigator.vibrate(30);
      }, 200);
    }, { passive: true });

    el.addEventListener("touchmove", (e) => {
      if (!active.current) {
        clearTimeout(longPressTimer.current);
        return;
      }
      e.preventDefault();
      const y = e.touches[0].clientY;
      let found = null;
      itemRefs.current.forEach((ref, idx) => {
        if (!ref) return;
        const r = ref.getBoundingClientRect();
        if (y >= r.top && y <= r.bottom) found = idx;
      });
      if (found !== null) {
        stateRef.current.overIdx = found;
        setOverIdx(found);
      }
    }, { passive: false });

    el.addEventListener("touchend", () => {
      clearTimeout(longPressTimer.current);
      const { pickedIdx: p, overIdx: o } = stateRef.current;
      if (active.current && p !== null && o !== null && p !== o) {
        onReorderRef.current(p, o);
      }
      active.current = false;
      stateRef.current = { pickedIdx: null, overIdx: null };
      setPickedIdx(null);
      setOverIdx(null);
      document.body.style.overflow = "";
    });
  };

  return { pickedIdx, overIdx, setRef };
}

// â”€â”€â”€ Main App â”€â”€â”€
function App() {
  const [cases, setCases] = useState([]);
  const [activeId, setActiveId] = useState(null);
  const [loaded, setLoaded] = useState(false);
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const isMobile = useIsMobile();
  const [deleteConfirmId, setDeleteConfirmId] = useState(null);
  const [sortMode, setSortMode] = useState("updated");

  const selectCase = (id) => { setActiveId(id); if (isMobile) setSidebarOpen(false); };

  useEffect(() => {
    (async () => {
      const d = await loadAllCases();
      setCases(d);
      if (d.length > 0) setActiveId(d[0].id);
      setLoaded(true);
    })();
  }, []);

  const prevCasesRef = useRef([]);
  useEffect(() => {
    if (!loaded) return;
    const prevMap = new Map(prevCasesRef.current.map(c => [c.id, c]));
    for (const c of cases) {
      const prev = prevMap.get(c.id);
      if (!prev || prev.name !== c.name || prev.memo !== c.memo || prev.notes !== c.notes || prev.entries !== c.entries || prev.files !== c.files || prev.updatedAt !== c.updatedAt) {
        saveCaseData(c);
      }
    }
    for (const prev of prevCasesRef.current) {
      if (!cases.find(c => c.id === prev.id)) deleteCaseData(prev.id);
    }
    prevCasesRef.current = cases;
  }, [cases, loaded]);

  const activeCase = cases.find(c => c.id === activeId) || null;

  const addCase = () => {
    const now = Date.now();
    const newC = { id: uid(), name: "æ–°è¦æ¡ˆä»¶", memo: "", notes: "", entries: [], files: [], createdAt: now, updatedAt: now };
    setCases(prev => [newC, ...prev]); setActiveId(newC.id); setSortMode("updated");
    if (isMobile) setSidebarOpen(false);
  };
  const updateCase = (id, patch) => {
    setCases(prev => prev.map(c => c.id === id ? { ...c, ...patch, updatedAt: Date.now() } : c));
  };
  const sortedCases = sortMode === "updated"
    ? [...cases].sort((a, b) => (b.updatedAt || b.createdAt) - (a.updatedAt || a.createdAt))
    : cases;

  // Drag sort for cases (PC)
  const [caseDragIdx, setCaseDragIdx] = useState(null);
  const [caseDragOverIdx, setCaseDragOverIdx] = useState(null);
  const handleCaseDragStart = (i) => { setCaseDragIdx(i); };
  const handleCaseDragOver = (e, i) => { e.preventDefault(); setCaseDragOverIdx(i); };
  const handleCaseDragEnd = () => {
    if (caseDragIdx !== null && caseDragOverIdx !== null && caseDragIdx !== caseDragOverIdx) {
      const reordered = [...sortedCases];
      const [moved] = reordered.splice(caseDragIdx, 1);
      reordered.splice(caseDragOverIdx, 0, moved);
      setCases(reordered); setSortMode("manual");
    }
    setCaseDragIdx(null); setCaseDragOverIdx(null);
  };
  // Touch drag for cases (mobile)
  const caseTouchDrag = useTouchDrag((from, to) => {
    const reordered = [...sortedCases];
    const [moved] = reordered.splice(from, 1);
    reordered.splice(to, 0, moved);
    setCases(reordered); setSortMode("manual");
  });

  const requestDelete = (id) => { setDeleteConfirmId(id); };
  const confirmDelete = async () => {
    const id = deleteConfirmId;
    const target = cases.find(c => c.id === id);
    if (target && target.files) {
      for (const f of target.files) await deleteFileData(f.id);
    }
    setCases(prev => prev.filter(c => c.id !== id));
    if (activeId === id) setActiveId(cases.find(c => c.id !== id)?.id || null);
    setDeleteConfirmId(null);
  };
  const cancelDelete = () => { setDeleteConfirmId(null); };
  const duplicateCase = async (c) => {
    const now = Date.now();
    const newFiles = [];
    for (const f of (c.files || [])) {
      const newId = uid();
      const dataUrl = await loadFileData(f.id);
      if (dataUrl) await saveFileData(newId, dataUrl);
      newFiles.push({ ...f, id: newId });
    }
    const dup = { ...c, id: uid(), name: c.name + "ï¼ˆã‚³ãƒ”ãƒ¼ï¼‰", createdAt: now, updatedAt: now, files: newFiles };
    setCases(prev => [dup, ...prev]); setActiveId(dup.id);
  };

  if (!loaded) return React.createElement("div", { style: { background: C.bg, color: C.text, height: "100vh", display: "flex", alignItems: "center", justifyContent: "center" } }, "èª­ã¿è¾¼ã¿ä¸­...");

  const topBtnStyle = { background: "none", border: "1px solid " + C.border, borderRadius: 6, color: C.text2, padding: "6px 10px", cursor: "pointer", fontSize: 14, flexShrink: 0 };

  return (
    <div style={{ fontFamily: font, background: C.bg, color: C.text, height: "100vh", display: "flex", overflow: "hidden" }}>
      {isMobile && sidebarOpen && <div onClick={() => setSidebarOpen(false)} style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.3)", zIndex: 99 }} />}
      {/* Sidebar */}
      <div style={{
        ...(isMobile ? { position: "fixed", top: 0, left: 0, bottom: 0, zIndex: 100, width: sidebarOpen ? "85vw" : 0, maxWidth: 320, boxShadow: sidebarOpen ? "4px 0 20px rgba(0,0,0,0.1)" : "none" }
          : { width: sidebarOpen ? 280 : 0, minWidth: sidebarOpen ? 280 : 0 }),
        background: C.surface, borderRight: "1px solid " + C.border, display: "flex", flexDirection: "column", transition: "all 0.25s ease", overflow: "hidden",
      }}>
        <div style={{ padding: "20px 16px 12px", borderBottom: "1px solid " + C.border }}>
          <div style={{ fontSize: 13, fontWeight: 700, color: C.accent, letterSpacing: 1.5, marginBottom: 4 }}>ä¸å‹•ç”£</div>
          <div style={{ fontSize: 18, fontWeight: 700, color: C.text }}>åæ”¯è¨ˆç®—æ©Ÿ</div>
        </div>
        <div style={{ padding: "12px 12px 8px" }}>
          <button onClick={addCase} style={{ width: "100%", padding: "10px 0", background: C.accent, color: C.white, border: "none", borderRadius: 8, fontWeight: 600, fontSize: 14, cursor: "pointer", fontFamily: font }}>ï¼‹ æ–°è¦æ¡ˆä»¶</button>
        </div>
        <div style={{ flex: 1, overflowY: "auto", padding: "4px 8px" }}>
          {sortedCases.map((c, i) => (
            <div key={c.id} ref={(el) => caseTouchDrag.setRef(i, el)}
              draggable={!isMobile}
              onDragStart={() => handleCaseDragStart(i)} onDragOver={(e) => handleCaseDragOver(e, i)} onDragEnd={handleCaseDragEnd}
              onClick={() => { if (caseTouchDrag.pickedIdx === null) selectCase(c.id); }}
              style={{ padding: "12px 12px", marginBottom: 4, borderRadius: 8, background: (caseDragIdx === i || caseTouchDrag.pickedIdx === i) ? "#DBEAFE" : c.id === activeId ? C.accentSoft : "transparent", borderLeft: c.id === activeId ? "3px solid " + C.accent : "3px solid transparent", borderTop: (caseDragOverIdx === i && caseDragIdx !== i) || (caseTouchDrag.overIdx === i && caseTouchDrag.pickedIdx !== null && caseTouchDrag.pickedIdx !== i) ? "3px solid " + C.accent : "none", opacity: (caseDragIdx === i || caseTouchDrag.pickedIdx === i) ? 0.4 : 1, cursor: isMobile ? "pointer" : "grab", transition: "all 0.1s", display: "flex", alignItems: "center", gap: 8, userSelect: "none" }}>
              <span style={{ color: C.text3, fontSize: 16, flexShrink: 0, userSelect: "none" }}>â ¿</span>
              <div style={{ flex: 1, minWidth: 0 }}>
                <div style={{ fontSize: 14, fontWeight: 600, color: c.id === activeId ? C.accent : C.text, marginBottom: 2, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{c.name}</div>
                <div style={{ fontSize: 11, color: C.text3 }}>{c.entries.length}ä»¶ã®è¨ˆç®— Â· {c.files.length}ä»¶ã®æ·»ä»˜</div>
              </div>
            </div>
          ))}
          {cases.length === 0 && <div style={{ padding: 20, textAlign: "center", color: C.text3, fontSize: 13 }}>æ¡ˆä»¶ãŒã‚ã‚Šã¾ã›ã‚“<br />ã€Œï¼‹ æ–°è¦æ¡ˆä»¶ã€ã‹ã‚‰ä½œæˆ</div>}
        </div>
        {/* Backup / Restore */}
        <div style={{ padding: "8px 12px 12px", borderTop: "1px solid " + C.border, display: "flex", gap: 6 }}>
          <button onClick={() => exportBackup(cases)} style={{ flex: 1, padding: "8px 0", background: C.surface2, color: C.text2, border: "1px solid " + C.border, borderRadius: 6, fontSize: 11, cursor: "pointer", fontFamily: font, fontWeight: 500 }}>ãƒ‡ãƒ¼ã‚¿ä¿å­˜</button>
          <label style={{ flex: 1, padding: "8px 0", background: C.surface2, color: C.text2, border: "1px solid " + C.border, borderRadius: 6, fontSize: 11, cursor: "pointer", fontFamily: font, fontWeight: 500, textAlign: "center" }}>
            ãƒ‡ãƒ¼ã‚¿èª­è¾¼
            <input type="file" accept=".json" style={{ display: "none" }} onChange={async (e) => {
              const file = e.target.files[0]; if (!file) return;
              try {
                const restored = await importBackup(file);
                setCases(restored);
                if (restored.length > 0) setActiveId(restored[0].id);
                alert("å¾©å…ƒã—ã¾ã—ãŸï¼ˆ" + restored.length + "ä»¶ï¼‰");
              } catch (err) { alert("å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸ: " + err.message); }
              e.target.value = "";
            }} />
          </label>
        </div>
      </div>

      {/* Main */}
      <div style={{ flex: 1, display: "flex", flexDirection: "column", overflow: "hidden" }}>
        <div style={{ padding: isMobile ? "10px 12px" : "12px 20px", borderBottom: "1px solid " + C.border, display: "flex", alignItems: "center", gap: isMobile ? 6 : 12, background: C.surface }}>
          <button onClick={() => setSidebarOpen(!sidebarOpen)} style={{ background: "none", border: "1px solid " + C.border, borderRadius: 6, color: C.text2, padding: "6px 10px", cursor: "pointer", fontSize: 16, flexShrink: 0 }}>â˜°</button>
          {activeCase && (<>
            <input value={activeCase.name} onChange={e => updateCase(activeCase.id, { name: e.target.value })} style={{ flex: 1, background: "transparent", border: "none", color: C.text, fontSize: isMobile ? 14 : 18, fontWeight: 700, fontFamily: font, outline: "none", minWidth: 0 }} placeholder="æ¡ˆä»¶å" />
            <button onClick={() => duplicateCase(activeCase)} style={{ ...topBtnStyle, color: C.gray, fontSize: isMobile ? 11 : 13, display: "flex", alignItems: "center", gap: 3, padding: isMobile ? "5px 7px" : "6px 10px", flexShrink: 0, whiteSpace: "nowrap" }}>â§‰ è¤‡è£½</button>
            <button onClick={() => requestDelete(activeCase.id)} style={{ ...topBtnStyle, background: "#DC2626", color: C.white, fontSize: isMobile ? 12 : 13, padding: isMobile ? "5px 10px" : "8px 14px", borderColor: "transparent", flexShrink: 0, whiteSpace: "nowrap", fontWeight: 600 }}>å‰Šé™¤</button>
          </>)}
        </div>
        <div style={{ flex: 1, overflowY: "auto", padding: isMobile ? "12px 12px 32px" : "20px 24px 40px" }}>
          {activeCase ? <CaseDetail c={activeCase} update={(patch) => updateCase(activeCase.id, patch)} onDelete={() => requestDelete(activeCase.id)} isMobile={isMobile} />
            : <div style={{ display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100%", color: C.text3 }}>
                <div style={{ fontSize: 48, marginBottom: 16, opacity: 0.3 }}>ğŸ¢</div>
                <div style={{ fontSize: 16 }}>{isMobile ? "â˜° ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰æ¡ˆä»¶ã‚’é¸æŠãƒ»ä½œæˆ" : "å·¦ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰æ¡ˆä»¶ã‚’é¸æŠã€ã¾ãŸã¯æ–°è¦ä½œæˆã—ã¦ãã ã•ã„"}</div>
              </div>}
        </div>
      </div>

      {/* Delete dialog */}
      {deleteConfirmId && (
        <div style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.6)", display: "flex", alignItems: "center", justifyContent: "center", zIndex: 1000 }} onClick={cancelDelete}>
          <div style={{ background: C.surface, border: "1px solid " + C.border, borderRadius: 14, padding: "28px 32px", maxWidth: 360, width: "90%", textAlign: "center" }} onClick={e => e.stopPropagation()}>
            <div style={{ fontSize: 16, fontWeight: 700, color: C.text, marginBottom: 8 }}>æ¡ˆä»¶ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ</div>
            <div style={{ fontSize: 13, color: C.text2, marginBottom: 24 }}>ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚</div>
            <div style={{ display: "flex", gap: 10 }}>
              <button onClick={cancelDelete} style={{ flex: 1, padding: "10px 0", background: C.surface2, color: C.text, border: "1px solid " + C.border, borderRadius: 8, fontWeight: 600, fontSize: 14, cursor: "pointer" }}>ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
              <button onClick={confirmDelete} style={{ flex: 1, padding: "10px 0", background: C.red, color: C.white, border: "none", borderRadius: 8, fontWeight: 600, fontSize: 14, cursor: "pointer" }}>å‰Šé™¤ã™ã‚‹</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// â”€â”€â”€ FileThumb (lazy-loads image from IndexedDB) â”€â”€â”€
function FileThumb({ f, onRemove }) {
  const [thumbUrl, setThumbUrl] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (f.type && f.type.startsWith("image/")) {
      setLoading(true);
      loadFileData(f.id).then(url => { setThumbUrl(url); setLoading(false); });
    }
  }, [f.id, f.type]);

  return (
    <div style={{ background: C.surface2, border: "1px solid " + C.border, borderRadius: 8, padding: "8px 12px", display: "flex", alignItems: "center", gap: 8, maxWidth: 260 }}>
      {f.type && f.type.startsWith("image/")
        ? (thumbUrl ? <img src={thumbUrl} alt={f.name} style={{ width: 36, height: 36, objectFit: "cover", borderRadius: 4 }} />
          : <div style={{ width: 36, height: 36, borderRadius: 4, background: C.surface2, display: "flex", alignItems: "center", justifyContent: "center", fontSize: 10, color: C.text3 }}>{loading ? "..." : "?"}</div>)
        : <div style={{ width: 36, height: 36, borderRadius: 4, background: C.accentSoft, display: "flex", alignItems: "center", justifyContent: "center", fontSize: 16 }}>{f.type && f.type.includes("pdf") ? "ğŸ“„" : "ğŸ“"}</div>}
      <div style={{ flex: 1, minWidth: 0 }}>
        <div style={{ fontSize: 12, fontWeight: 500, color: C.text, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{f.name}</div>
        <div style={{ fontSize: 10, color: C.text3 }}>{(f.size / 1024).toFixed(0)} KB</div>
      </div>
      <button onClick={onRemove} style={{ background: "none", border: "none", color: C.text3, cursor: "pointer", fontSize: 12 }}>âœ•</button>
    </div>
  );
}

// â”€â”€â”€ CalcPad (mobile calculator UI) â”€â”€â”€
function CalcPad({ value, onChange, onAdd, onClose, preview, addLabel = "è¿½åŠ " }) {
  const insert = (s) => onChange(value + s);
  const backspace = () => onChange(value.slice(0, -1));
  const clear = () => onChange("");

  const btnBase = { border: "none", borderRadius: 8, fontSize: 18, fontWeight: 600, cursor: "pointer", fontFamily: "'JetBrains Mono', monospace", display: "flex", alignItems: "center", justifyContent: "center", userSelect: "none", WebkitTapHighlightColor: "transparent" };
  const numBtn = { ...btnBase, background: C.surface, color: C.text, height: 52 };
  const opBtn = { ...btnBase, background: C.accentSoft, color: C.accent, height: 52 };
  const fnBtn = { ...btnBase, background: C.surface2, color: C.text2, height: 52 };

  return (
    <div style={{ position: "fixed", bottom: 0, left: 0, right: 0, zIndex: 200, background: C.bg, borderTop: "2px solid " + C.border, boxShadow: "0 -4px 20px rgba(0,0,0,0.1)", padding: "8px 8px 16px", paddingBottom: "max(16px, env(safe-area-inset-bottom))" }}>
      {/* Display */}
      <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 6, padding: "0 4px" }}>
        <div style={{ flex: 1, minWidth: 0, background: C.surface, border: "1px solid " + C.border, borderRadius: 8, padding: "10px 12px", fontFamily: "'JetBrains Mono', monospace", fontSize: 16, color: C.text, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap", minHeight: 20 }}>
          {value || <span style={{ color: C.text3 }}>è¨ˆç®—å¼ã‚’å…¥åŠ›</span>}
        </div>
        <button onClick={onClose} style={{ ...fnBtn, width: 44, height: 40, fontSize: 14, flexShrink: 0 }}>âœ•</button>
      </div>
      {/* Preview */}
      {value.trim() && (
        <div style={{ padding: "4px 8px", marginBottom: 6, textAlign: "right", fontFamily: "'JetBrains Mono', monospace" }}>
          {preview?.ok
            ? <span style={{ fontSize: 20, fontWeight: 700, color: preview.value >= 0 ? C.green : C.red }}>= {preview.value < 0 ? "â–³ " : ""}{formatNumber(Math.abs(preview.value))}</span>
            : <span style={{ fontSize: 12, color: C.red }}>{preview?.message}</span>}
        </div>
      )}
      {/* Keypad */}
      <div style={{ display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 6 }}>
        <button style={fnBtn} onClick={clear}>AC</button>
        <button style={fnBtn} onClick={() => insert("(")}>(</button>
        <button style={fnBtn} onClick={() => insert(")")}>)</button>
        <button style={opBtn} onClick={() => insert(" / ")}>Ã·</button>

        <button style={numBtn} onClick={() => insert("7")}>7</button>
        <button style={numBtn} onClick={() => insert("8")}>8</button>
        <button style={numBtn} onClick={() => insert("9")}>9</button>
        <button style={opBtn} onClick={() => insert(" * ")}>Ã—</button>

        <button style={numBtn} onClick={() => insert("4")}>4</button>
        <button style={numBtn} onClick={() => insert("5")}>5</button>
        <button style={numBtn} onClick={() => insert("6")}>6</button>
        <button style={opBtn} onClick={() => insert(" - ")}>âˆ’</button>

        <button style={numBtn} onClick={() => insert("1")}>1</button>
        <button style={numBtn} onClick={() => insert("2")}>2</button>
        <button style={numBtn} onClick={() => insert("3")}>3</button>
        <button style={opBtn} onClick={() => insert(" + ")}>+</button>

        <button style={numBtn} onClick={() => insert("0")}>0</button>
        <button style={numBtn} onClick={() => insert(".")}>.</button>
        <button style={{ ...fnBtn, fontSize: 16 }} onClick={backspace}>âŒ«</button>
        <button style={{ ...btnBase, background: value.trim() && preview?.ok ? C.accent : C.border, color: C.white, height: 52 }} onClick={() => { if (value.trim() && preview?.ok) { onAdd(); } }}>{addLabel}</button>
      </div>
    </div>
  );
}

// â”€â”€â”€ CaseDetail â”€â”€â”€
function CaseDetail({ c, update, onDelete, isMobile }) {
  const [expr, setExpr] = useState("");
  const [memo, setMemo] = useState("");
  const [error, setError] = useState("");
  const [calcPadOpen, setCalcPadOpen] = useState(false);
  const [editingEntryId, setEditingEntryId] = useState(null);
  const inputRef = useRef(null);

  // Drag sort for entries (PC)
  const [dragIdx, setDragIdx] = useState(null);
  const [dragOverIdx, setDragOverIdx] = useState(null);
  const handleDragStart = (i) => { setDragIdx(i); };
  const handleDragOver = (e, i) => { e.preventDefault(); setDragOverIdx(i); };
  const handleDragEnd = () => {
    if (dragIdx !== null && dragOverIdx !== null && dragIdx !== dragOverIdx) {
      const ne = [...c.entries]; const [moved] = ne.splice(dragIdx, 1); ne.splice(dragOverIdx, 0, moved); update({ entries: ne });
    }
    setDragIdx(null); setDragOverIdx(null);
  };
  // Touch drag for entries (mobile)
  const entryTouchDrag = useTouchDrag((from, to) => {
    const ne = [...c.entries]; const [moved] = ne.splice(from, 1); ne.splice(to, 0, moved); update({ entries: ne });
  });

  const addEntry = () => {
    try {
      const result = evaluate(expr);
      update({ entries: [...c.entries, { id: uid(), type: "calc", expr, memo, result }] });
      setExpr(""); setMemo(""); setError("");
      setCalcPadOpen(false);
    } catch (e) { setError(e.message); }
    if (!isMobile) inputRef.current?.focus();
  };

  // Open CalcPad for editing existing entry (mobile only)
  const openEditCalcPad = (entry) => {
    if (!isMobile) return;
    setEditingEntryId(entry.id);
    setExpr(entry.expr);
    setCalcPadOpen(true);
  };

  // Confirm edit from CalcPad
  const confirmEditEntry = () => {
    if (!editingEntryId) return;
    try {
      const result = evaluate(expr);
      update({ entries: c.entries.map(e => e.id === editingEntryId ? { ...e, expr, result } : e) });
      setExpr(""); setError(""); setCalcPadOpen(false); setEditingEntryId(null);
    } catch (e) { setError(e.message); }
  };

  const closeCalcPad = () => {
    setCalcPadOpen(false); setEditingEntryId(null); setExpr(""); setError("");
  };

  const removeEntry = (eid) => { update({ entries: c.entries.filter(e => e.id !== eid) }); };
  const updateEntryMemo = (eid, v) => { update({ entries: c.entries.map(e => e.id === eid ? { ...e, memo: v } : e) }); };
  const updateEntryExpr = (eid, v) => {
    let r; try { r = evaluate(v); } catch { r = null; }
    update({ entries: c.entries.map(e => e.id === eid ? { ...e, expr: v, result: r !== null ? r : e.result } : e) });
  };

  const addFile = (e) => {
    const fl = e.target.files; if (!fl) return;
    Array.from(fl).forEach(file => {
      const reader = new FileReader();
      reader.onload = async (ev) => {
        const fileId = uid();
        await saveFileData(fileId, ev.target.result);
        update({ files: [...c.files, { id: fileId, name: file.name, type: file.type, size: file.size }] });
      };
      reader.readAsDataURL(file);
    });
    e.target.value = "";
  };
  const removeFile = async (fid) => {
    await deleteFileData(fid);
    update({ files: c.files.filter(f => f.id !== fid) });
  };

  const preview = (() => {
    if (!expr.trim()) return null;
    try { return { ok: true, value: evaluate(expr) }; } catch (e) { return { ok: false, message: e.message }; }
  })();

  const handleKeyDown = (e) => { if (e.key === "Enter" && expr.trim() && preview?.ok) { e.preventDefault(); addEntry(); } };

  return (
    <div style={{ maxWidth: 860, margin: "0 auto" }}>
      <div style={{ marginBottom: 24 }}>
        <textarea value={c.memo} onChange={e => update({ memo: e.target.value })} placeholder="æ¡ˆä»¶ãƒ¡ãƒ¢ï¼ˆæ‰€åœ¨åœ°ã€ç‰©ä»¶æ¦‚è¦ãªã©è‡ªç”±ã«è¨˜å…¥ï¼‰" rows={2}
          style={{ width: "100%", background: C.surface, border: "1px solid " + C.border, borderRadius: 8, padding: "10px 14px", color: C.text, fontSize: 13, fontFamily: font, resize: "vertical", outline: "none", boxSizing: "border-box" }} />
      </div>

      <div style={{ background: C.surface, border: "1px solid " + C.border, borderRadius: 12, padding: 16, marginBottom: 20 }}>
        <div style={{ display: "flex", flexDirection: "column", gap: 8, marginBottom: 8 }}>
          <input ref={inputRef} value={memo} onChange={e => setMemo(e.target.value)} placeholder="ãƒ¡ãƒ¢ï¼ˆä¾‹ï¼šå®¶è³ƒåå…¥ï¼‰"
            style={{ width: "100%", background: C.surface2, border: "1px solid " + C.border, borderRadius: 6, padding: "8px 12px", color: C.text, fontSize: 13, fontFamily: font, outline: "none", boxSizing: "border-box" }} />
          <div style={{ display: "flex", gap: 8 }}>
            <input value={editingEntryId ? "" : expr}
              readOnly={isMobile}
              onFocus={() => { if (isMobile) { setEditingEntryId(null); setExpr(""); setCalcPadOpen(true); } }}
              onClick={() => { if (isMobile) { setEditingEntryId(null); setExpr(""); setCalcPadOpen(true); } }}
              onChange={e => { if (!isMobile) { setExpr(e.target.value); setError(""); } }}
              onKeyDown={!isMobile ? handleKeyDown : undefined}
              placeholder="è¨ˆç®—å¼ã‚’å…¥åŠ›"
              style={{ flex: 1, background: (calcPadOpen && !editingEntryId) ? C.accentSoft : C.surface2, border: "1px solid " + (error && !editingEntryId ? C.red : (calcPadOpen && !editingEntryId) ? C.accent : C.border), borderRadius: 6, padding: "8px 14px", color: C.text, fontSize: 15, fontFamily: "'JetBrains Mono', monospace", outline: "none", boxSizing: "border-box", caretColor: isMobile ? "transparent" : "auto" }} />
            {!isMobile && <button onClick={addEntry} disabled={!expr.trim()} style={{ background: C.accent, color: C.white, border: "none", borderRadius: 6, padding: "8px 18px", fontWeight: 600, fontSize: 14, cursor: expr.trim() ? "pointer" : "default", opacity: expr.trim() ? 1 : 0.4, whiteSpace: "nowrap" }}>ï¼‹ è¿½åŠ </button>}
          </div>
        </div>
        {!calcPadOpen && expr.trim() && (
          <div style={{ marginTop: 8, padding: "10px 16px", background: preview?.ok ? C.surface2 : C.redSoft, borderRadius: 8, display: "flex", alignItems: "center", justifyContent: "space-between" }}>
            <span style={{ fontFamily: "'JetBrains Mono', monospace", fontSize: 13, color: C.text3 }}>{expr}</span>
            {preview?.ok
              ? <span style={{ fontFamily: "'JetBrains Mono', monospace", fontSize: 20, fontWeight: 700, color: preview.value >= 0 ? C.green : C.red }}>= {preview.value < 0 ? "â–³ " : ""}{formatNumber(Math.abs(preview.value))}</span>
              : <span style={{ fontSize: 12, color: C.red }}>{preview?.message}</span>}
          </div>
        )}
        {error && <div style={{ color: C.red, fontSize: 12, marginTop: 4 }}>{error}</div>}
      </div>

      {c.entries.length > 0 && (
        <div style={{ background: C.surface, border: "1px solid " + C.border, borderRadius: 12, overflow: "hidden", marginBottom: 24 }}>
          {c.entries.map((e, i) => {
            return (
              <div key={e.id} ref={(el) => entryTouchDrag.setRef(i, el)}
                draggable={!isMobile}
                onDragStart={() => handleDragStart(i)} onDragOver={(ev) => handleDragOver(ev, i)} onDragEnd={handleDragEnd}
                style={{ padding: "12px 16px", borderBottom: i < c.entries.length - 1 ? "1px solid " + C.border : "none", borderTop: (dragOverIdx === i && dragIdx !== i) || (entryTouchDrag.overIdx === i && entryTouchDrag.pickedIdx !== null && entryTouchDrag.pickedIdx !== i) ? "3px solid " + C.accent : "none", background: (dragIdx === i || entryTouchDrag.pickedIdx === i) ? "#DBEAFE" : "transparent", opacity: (dragIdx === i || entryTouchDrag.pickedIdx === i) ? 0.4 : 1, cursor: isMobile ? "default" : "grab", display: "flex", gap: 10, alignItems: "stretch", userSelect: "none" }}>
                <div style={{ display: "flex", alignItems: "center", color: C.text3, fontSize: 16, userSelect: "none", padding: "0 2px", flexShrink: 0 }}>â ¿</div>
                <div style={{ flex: 1, minWidth: 0 }}>
                  <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 4 }}>
                    <input value={e.memo} onChange={ev => updateEntryMemo(e.id, ev.target.value)} style={{ background: "transparent", border: "none", color: C.text, fontSize: 13, fontWeight: 500, fontFamily: font, outline: "none", flex: 1 }} placeholder="ãƒ¡ãƒ¢ãªã—" />
                    <button onClick={() => removeEntry(e.id)} style={{ background: C.grayBg, border: "none", color: C.white, cursor: "pointer", fontSize: 11, fontWeight: 600, padding: "4px 10px", borderRadius: 6, flexShrink: 0 }}>å‰Šé™¤</button>
                  </div>
                  <div style={{ display: "flex", alignItems: "baseline", justifyContent: "space-between", gap: 12 }}>
                    <input value={e.expr}
                      readOnly={isMobile}
                      onClick={() => openEditCalcPad(e)}
                      onChange={ev => { if (!isMobile) updateEntryExpr(e.id, ev.target.value); }}
                      style={{ fontFamily: "'JetBrains Mono', monospace", fontSize: 13, color: C.text2, background: (editingEntryId === e.id) ? C.accentSoft : "transparent", border: "none", borderBottom: "1px dashed " + ((editingEntryId === e.id) ? C.accent : C.border), outline: "none", flex: 1, minWidth: 0, padding: "2px 0", borderRadius: (editingEntryId === e.id) ? 4 : 0 }} />
                    <div style={{ fontFamily: "'JetBrains Mono', monospace", fontSize: 18, fontWeight: 700, flexShrink: 0, whiteSpace: "nowrap", color: e.result >= 0 ? C.green : C.red }}>
                      = {e.result < 0 ? "â–³ " : ""}{formatNumber(Math.abs(e.result))}
                    </div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      )}

      {/* Notes / URLs */}
      <div style={{ background: C.surface, border: "1px solid " + C.border, borderRadius: 12, padding: 16, marginBottom: 20 }}>
        <textarea value={c.notes || ""} onChange={e => update({ notes: e.target.value })} placeholder={"å‚è€ƒURLã€å‚™è€ƒãªã©ã‚’è‡ªç”±ã«è¨˜å…¥\nä¾‹: https://suumo.jp/..."} rows={3}
          style={{ width: "100%", background: C.surface2, border: "1px solid " + C.border, borderRadius: 8, padding: "10px 14px", color: C.text, fontSize: 13, fontFamily: font, resize: "vertical", outline: "none", boxSizing: "border-box", lineHeight: 1.6 }} />
        {(c.notes || "").match(/https?:\/\/[^\s]+/g) && (
          <div style={{ marginTop: 8, display: "flex", flexDirection: "column", gap: 4 }}>
            {(c.notes || "").match(/https?:\/\/[^\s]+/g).map((url, i) => (
              <a key={i} href={url} target="_blank" rel="noopener noreferrer" style={{ fontSize: 12, color: C.accent, wordBreak: "break-all", textDecoration: "none" }}>
                ğŸ”— {url.length > 60 ? url.slice(0, 60) + "..." : url}
              </a>
            ))}
          </div>
        )}
      </div>

      {/* File attachments */}
      <div style={{ background: C.surface, border: "1px solid " + C.border, borderRadius: 12, padding: 16 }}>
        <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 12 }}>
          <div style={{ fontSize: 14, fontWeight: 600, color: C.text2 }}>ğŸ“ æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«</div>
          <label style={{ background: C.surface2, border: "1px solid " + C.border, borderRadius: 6, padding: "6px 14px", fontSize: 13, color: C.text, cursor: "pointer" }}>
            ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ 
            <input type="file" multiple onChange={addFile} style={{ display: "none" }} />
          </label>
        </div>
        {c.files.length === 0 && <div style={{ color: C.text3, fontSize: 13, textAlign: "center", padding: "16px 0" }}>æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“</div>}
        <div style={{ display: "flex", flexWrap: "wrap", gap: 8 }}>
          {c.files.map(f => (
            <FileThumb key={f.id} f={f} onRemove={() => removeFile(f.id)} />
          ))}
        </div>
      </div>
      {/* Bottom padding when calcPad is open */}
      {isMobile && calcPadOpen && <div style={{ height: 340 }} />}
      {/* Mobile CalcPad */}
      {isMobile && calcPadOpen && (
        <div onClick={closeCalcPad} style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, zIndex: 199, background: "transparent" }} />
      )}
      {isMobile && calcPadOpen && (
        <CalcPad
          value={expr}
          onChange={(v) => { setExpr(v); setError(""); }}
          onAdd={editingEntryId ? confirmEditEntry : addEntry}
          onClose={closeCalcPad}
          preview={(() => { if (!expr.trim()) return null; try { return { ok: true, value: evaluate(expr) }; } catch (e) { return { ok: false, message: e.message }; } })()}
          addLabel={editingEntryId ? "ç¢ºå®š" : "è¿½åŠ "}
        />
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('./sw.js').then(function(reg) {
      console.log('SW registered:', reg.scope);
    }).catch(function(err) {
      console.log('SW registration failed:', err);
    });
  });
}
</script>
</body>
</html>
