<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ä¸å‹•ç”£åæ”¯è¨ˆç®—æ©Ÿ</title>
<!-- PWA meta tags -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="åæ”¯è¨ˆç®—æ©Ÿ">
<meta name="theme-color" content="#2563EB">
<meta name="description" content="ä¸å‹•ç”£æŠ•è³‡ã®æ¡ˆä»¶åˆ¥åæ”¯è¨ˆç®—æ©Ÿ">
<!-- App icon (inline SVG as data URL) -->
<link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxODAgMTgwIj48cmVjdCB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgcng9IjQwIiBmaWxsPSIjMjU2M0VCIi8+PHRleHQgeD0iOTAiIHk9IjcwIiBmb250LXNpemU9IjQ4IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtd2VpZ2h0PSI3MDAiPuS4jeWLleeUozwvdGV4dD48dGV4dCB4PSI5MCIgeT0iMTI1IiBmb250LXNpemU9IjQwIiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtd2VpZ2h0PSI3MDAiPuioiOeul+apnzwvdGV4dD48L3N2Zz4=">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxODAgMTgwIj48cmVjdCB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgcng9IjQwIiBmaWxsPSIjMjU2M0VCIi8+PHRleHQgeD0iOTAiIHk9IjcwIiBmb250LXNpemU9IjQ4IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtd2VpZ2h0PSI3MDAiPuS4jeWLleeUozwvdGV4dD48dGV4dCB4PSI5MCIgeT0iMTI1IiBmb250LXNpemU9IjQwIiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtd2VpZ2h0PSI3MDAiPuioiOeul+apnzwvdGV4dD48L3N2Zz4=">
<!-- Manifest (inline) -->
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoi5LiN5YuV55Sj5Y+O5pSv6KiI566X5qmfIiwic2hvcnRfbmFtZSI6IuWPjuaUr+ioiOeul+apnyIsInN0YXJ0X3VybCI6Ii4vIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiI0Y1RjZGOCIsInRoZW1lX2NvbG9yIjoiIzI1NjNFQiIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBeE9EQWdNVGd3SWo0OGNtVmpkQ0IzYVdSMGFEMGlNVGd3SWlCb1pXbG5hSFE5SWpFNE1DSWdjbmc5SWpRd0lpQm1hV3hzUFNJak1qVTJNMFZDSWk4K1BIUmxlSFFnZUQwaU9UQWlJSGs5SWpjd0lpQm1iMjUwTFhOcGVtVTlJalE0SWlCbWFXeHNQU0ozYUdsMFpTSWdkR1Y0ZEMxaGJtTm9iM0k5SW0xcFpHUnNaU0lnWm05dWRDMW1ZVzFwYkhrOUluTmhibk10YzJWeWFXWWlJR1p2Ym5RdGQyVnBaMmgwUFNJM01EQWlQdWlvcDcyYjVZK1g1cFd6UEM5MFpYaDBQangwWlhoMElIZzlJamt3SWlCNVBTSXhNalVpSUdadmJuUXRjMmw2WlQwaU5EQWlJR1pwYkd3OUluZG9hWFJsSWlCMFpYaDBMV0Z1WTJodmNqMGliV2xrWkd4bElpQm1iMjUwTFdaaGJXbHNlVDBpYzJGdWN5MXpaWEpwWmlJZ1ptOXVkQzEzWldsbmFIUTlJamN3TUNJK3ZLZnZudmFwcHVhcHB6d3ZkR1Y0ZEQ0OEwzTjJaejQ9Iiwic2l6ZXMiOiIxODB4MTgwIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifV19">
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body, #root { height: 100%; }
body { font-family: 'DM Sans', 'Noto Sans JP', sans-serif; -webkit-tap-highlight-color: transparent; }
input, textarea, button { font-family: inherit; }
/* Safe area for notched iPhones */
@supports (padding: env(safe-area-inset-top)) {
  body { padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); padding-left: env(safe-area-inset-left); padding-right: env(safe-area-inset-right); }
}
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;

// â”€â”€â”€ Math expression parser â”€â”€â”€
function tokenize(expr) {
  const tokens = [];
  let i = 0;
  while (i < expr.length) {
    if (expr[i] === " ") { i++; continue; }
    if ("0123456789.".includes(expr[i])) {
      let num = "";
      while (i < expr.length && "0123456789.".includes(expr[i])) { num += expr[i++]; }
      tokens.push({ type: "num", value: parseFloat(num) });
    } else if ("+-*/".includes(expr[i])) {
      tokens.push({ type: "op", value: expr[i++] });
    } else if (expr[i] === "(") {
      tokens.push({ type: "lparen" }); i++;
    } else if (expr[i] === ")") {
      tokens.push({ type: "rparen" }); i++;
    } else {
      throw new Error("ä¸æ­£ãªæ–‡å­—: " + expr[i]);
    }
  }
  return tokens;
}
function parseExpr(tokens, pos) {
  let [left, p] = parseTerm(tokens, pos);
  while (p < tokens.length && tokens[p].type === "op" && (tokens[p].value === "+" || tokens[p].value === "-")) {
    const op = tokens[p].value; p++;
    let [right, np] = parseTerm(tokens, p); left = op === "+" ? left + right : left - right; p = np;
  }
  return [left, p];
}
function parseTerm(tokens, pos) {
  let [left, p] = parseFactor(tokens, pos);
  while (p < tokens.length && tokens[p].type === "op" && (tokens[p].value === "*" || tokens[p].value === "/")) {
    const op = tokens[p].value; p++;
    let [right, np] = parseFactor(tokens, p); left = op === "*" ? left * right : left / right; p = np;
  }
  return [left, p];
}
function parseFactor(tokens, pos) {
  if (pos >= tokens.length) throw new Error("å¼ãŒä¸å®Œå…¨ã§ã™");
  if (tokens[pos].type === "op" && tokens[pos].value === "-") {
    let [val, p] = parseFactor(tokens, pos + 1); return [-val, p];
  }
  if (tokens[pos].type === "num") return [tokens[pos].value, pos + 1];
  if (tokens[pos].type === "lparen") {
    let [val, p] = parseExpr(tokens, pos + 1);
    if (p >= tokens.length || tokens[p].type !== "rparen") throw new Error("ã‚«ãƒƒã‚³ãŒé–‰ã˜ã¦ã„ã¾ã›ã‚“");
    return [val, p + 1];
  }
  throw new Error("ä¸æ­£ãªå¼ã§ã™");
}
function evaluate(expr) {
  if (!expr.trim()) throw new Error("å¼ãŒç©ºã§ã™");
  const tokens = tokenize(expr);
  const [result, pos] = parseExpr(tokens, 0);
  if (pos !== tokens.length) throw new Error("ä¸æ­£ãªå¼ã§ã™");
  return result;
}
function formatNumber(n) {
  if (Number.isNaN(n) || !Number.isFinite(n)) return "ã‚¨ãƒ©ãƒ¼";
  const fixed = Math.abs(n) < 1e-10 ? 0 : n;
  return new Intl.NumberFormat("ja-JP", { maximumFractionDigits: 4 }).format(fixed);
}
function uid() { return Date.now().toString(36) + Math.random().toString(36).slice(2, 8); }

// â”€â”€â”€ localStorage helpers â”€â”€â”€
function loadData(key, fallback) {
  try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; } catch { return fallback; }
}
function saveData(key, val) {
  try { localStorage.setItem(key, JSON.stringify(val)); } catch (e) { console.error(e); }
}
function deleteData(key) {
  try { localStorage.removeItem(key); } catch (e) { console.error(e); }
}
function loadAllCases() {
  const index = loadData("re-calc-index", []);
  return index.map(meta => {
    const full = loadData("re-calc-case:" + meta.id, null);
    return full ? { ...meta, ...full } : { ...meta, memo: "", entries: [], files: [] };
  });
}
function saveCaseIndex(cases) {
  saveData("re-calc-index", cases.map(c => ({ id: c.id, name: c.name, createdAt: c.createdAt, updatedAt: c.updatedAt })));
}
function saveCaseData(c) {
  saveData("re-calc-case:" + c.id, { memo: c.memo, entries: c.entries, files: c.files });
}
function deleteCaseData(id) { deleteData("re-calc-case:" + id); }

// â”€â”€â”€ Colors â”€â”€â”€
const C = {
  bg: "#F5F6F8", surface: "#FFFFFF", surface2: "#F0F1F4",
  border: "#D9DCE3", border2: "#C5C9D3",
  accent: "#2563EB", accent2: "#1D4FD7", accentSoft: "rgba(37,99,235,0.08)",
  green: "#16A34A", greenSoft: "rgba(22,163,74,0.08)",
  red: "#DC2626", redSoft: "rgba(220,38,38,0.08)",
  amber: "#D97706", amberSoft: "rgba(217,119,6,0.08)",
  text: "#1A1A1A", text2: "#6B7280", text3: "#9CA3AF",
  white: "#FFFFFF", gray: "#6B7280", grayBg: "#6B7280",
};
const font = "'DM Sans', 'Noto Sans JP', sans-serif";

function useIsMobile(bp = 640) {
  const [m, setM] = useState(window.innerWidth < bp);
  useEffect(() => { const f = () => setM(window.innerWidth < bp); window.addEventListener("resize", f); return () => window.removeEventListener("resize", f); }, []);
  return m;
}

// â”€â”€â”€ Main App â”€â”€â”€
function App() {
  const [cases, setCases] = useState([]);
  const [activeId, setActiveId] = useState(null);
  const [loaded, setLoaded] = useState(false);
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const isMobile = useIsMobile();
  const [deleteConfirmId, setDeleteConfirmId] = useState(null);
  const [sortMode, setSortMode] = useState("updated");
  const [caseDragIdx, setCaseDragIdx] = useState(null);
  const [caseDragOverIdx, setCaseDragOverIdx] = useState(null);

  const selectCase = (id) => { setActiveId(id); if (isMobile) setSidebarOpen(false); };

  useEffect(() => {
    const d = loadAllCases();
    setCases(d);
    if (d.length > 0) setActiveId(d[0].id);
    setLoaded(true);
  }, []);

  const prevCasesRef = useRef([]);
  useEffect(() => {
    if (!loaded) return;
    saveCaseIndex(cases);
    const prevMap = new Map(prevCasesRef.current.map(c => [c.id, c]));
    for (const c of cases) {
      const prev = prevMap.get(c.id);
      if (!prev || prev.memo !== c.memo || prev.entries !== c.entries || prev.files !== c.files) saveCaseData(c);
    }
    for (const prev of prevCasesRef.current) {
      if (!cases.find(c => c.id === prev.id)) deleteCaseData(prev.id);
    }
    prevCasesRef.current = cases;
  }, [cases, loaded]);

  const activeCase = cases.find(c => c.id === activeId) || null;

  const addCase = () => {
    const now = Date.now();
    const newC = { id: uid(), name: "æ–°è¦æ¡ˆä»¶", memo: "", entries: [], files: [], createdAt: now, updatedAt: now };
    setCases(prev => [newC, ...prev]); setActiveId(newC.id); setSortMode("updated");
    if (isMobile) setSidebarOpen(false);
  };
  const updateCase = (id, patch) => {
    setCases(prev => prev.map(c => c.id === id ? { ...c, ...patch, updatedAt: Date.now() } : c));
  };
  const sortedCases = sortMode === "updated"
    ? [...cases].sort((a, b) => (b.updatedAt || b.createdAt) - (a.updatedAt || a.createdAt))
    : cases;

  const handleCaseDragStart = (idx) => { setCaseDragIdx(idx); };
  const handleCaseDragOver = (e, idx) => { e.preventDefault(); setCaseDragOverIdx(idx); };
  const handleCaseDragEnd = () => {
    if (caseDragIdx !== null && caseDragOverIdx !== null && caseDragIdx !== caseDragOverIdx) {
      const reordered = [...sortedCases];
      const [moved] = reordered.splice(caseDragIdx, 1);
      reordered.splice(caseDragOverIdx, 0, moved);
      setCases(reordered); setSortMode("manual");
    }
    setCaseDragIdx(null); setCaseDragOverIdx(null);
  };

  const requestDelete = (id) => { setDeleteConfirmId(id); };
  const confirmDelete = () => {
    const id = deleteConfirmId;
    setCases(prev => prev.filter(c => c.id !== id));
    if (activeId === id) setActiveId(cases.find(c => c.id !== id)?.id || null);
    setDeleteConfirmId(null);
  };
  const cancelDelete = () => { setDeleteConfirmId(null); };
  const duplicateCase = (c) => {
    const now = Date.now();
    const dup = { ...c, id: uid(), name: c.name + "ï¼ˆã‚³ãƒ”ãƒ¼ï¼‰", createdAt: now, updatedAt: now, files: [] };
    setCases(prev => [dup, ...prev]); setActiveId(dup.id);
  };

  if (!loaded) return React.createElement("div", { style: { background: C.bg, color: C.text, height: "100vh", display: "flex", alignItems: "center", justifyContent: "center" } }, "èª­ã¿è¾¼ã¿ä¸­...");

  const topBtnStyle = { background: "none", border: "1px solid " + C.border, borderRadius: 6, color: C.text2, padding: "6px 10px", cursor: "pointer", fontSize: 14 };

  return (
    <div style={{ fontFamily: font, background: C.bg, color: C.text, height: "100vh", display: "flex", overflow: "hidden" }}>
      {isMobile && sidebarOpen && <div onClick={() => setSidebarOpen(false)} style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.3)", zIndex: 99 }} />}
      {/* Sidebar */}
      <div style={{
        ...(isMobile ? { position: "fixed", top: 0, left: 0, bottom: 0, zIndex: 100, width: sidebarOpen ? "85vw" : 0, maxWidth: 320, boxShadow: sidebarOpen ? "4px 0 20px rgba(0,0,0,0.1)" : "none" }
          : { width: sidebarOpen ? 280 : 0, minWidth: sidebarOpen ? 280 : 0 }),
        background: C.surface, borderRight: "1px solid " + C.border, display: "flex", flexDirection: "column", transition: "all 0.25s ease", overflow: "hidden",
      }}>
        <div style={{ padding: "20px 16px 12px", borderBottom: "1px solid " + C.border }}>
          <div style={{ fontSize: 13, fontWeight: 700, color: C.accent, letterSpacing: 1.5, marginBottom: 4 }}>ä¸å‹•ç”£</div>
          <div style={{ fontSize: 18, fontWeight: 700, color: C.text }}>åæ”¯è¨ˆç®—æ©Ÿ</div>
        </div>
        <div style={{ padding: "12px 12px 8px" }}>
          <button onClick={addCase} style={{ width: "100%", padding: "10px 0", background: C.accent, color: C.white, border: "none", borderRadius: 8, fontWeight: 600, fontSize: 14, cursor: "pointer", fontFamily: font }}>ï¼‹ æ–°è¦æ¡ˆä»¶</button>
        </div>
        <div style={{ flex: 1, overflowY: "auto", padding: "4px 8px" }}>
          {sortedCases.map((c, i) => (
            <div key={c.id} draggable onDragStart={() => handleCaseDragStart(i)} onDragOver={(ev) => handleCaseDragOver(ev, i)} onDragEnd={handleCaseDragEnd}
              onClick={() => selectCase(c.id)}
              style={{ padding: "12px 12px", marginBottom: 4, borderRadius: 8, background: c.id === activeId ? C.accentSoft : "transparent", borderLeft: c.id === activeId ? "3px solid " + C.accent : "3px solid transparent", borderTop: caseDragOverIdx === i ? "2px solid " + C.accent : "none", opacity: caseDragIdx === i ? 0.5 : 1, cursor: "pointer", transition: "all 0.15s", display: "flex", alignItems: "center", gap: 8 }}>
              <span style={{ color: C.text3, fontSize: 14, flexShrink: 0, userSelect: "none", cursor: "grab" }}>â ¿</span>
              <div style={{ flex: 1, minWidth: 0 }}>
                <div style={{ fontSize: 14, fontWeight: 600, color: c.id === activeId ? C.accent : C.text, marginBottom: 2, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{c.name}</div>
                <div style={{ fontSize: 11, color: C.text3 }}>{c.entries.length}ä»¶ã®è¨ˆç®— Â· {c.files.length}ä»¶ã®æ·»ä»˜</div>
              </div>
            </div>
          ))}
          {cases.length === 0 && <div style={{ padding: 20, textAlign: "center", color: C.text3, fontSize: 13 }}>æ¡ˆä»¶ãŒã‚ã‚Šã¾ã›ã‚“<br />ã€Œï¼‹ æ–°è¦æ¡ˆä»¶ã€ã‹ã‚‰ä½œæˆ</div>}
        </div>
      </div>

      {/* Main */}
      <div style={{ flex: 1, display: "flex", flexDirection: "column", overflow: "hidden" }}>
        <div style={{ padding: isMobile ? "10px 12px" : "12px 20px", borderBottom: "1px solid " + C.border, display: "flex", alignItems: "center", gap: isMobile ? 8 : 12, background: C.surface }}>
          <button onClick={() => setSidebarOpen(!sidebarOpen)} style={{ background: "none", border: "1px solid " + C.border, borderRadius: 6, color: C.text2, padding: "6px 10px", cursor: "pointer", fontSize: 16 }}>â˜°</button>
          {activeCase && (<>
            <input value={activeCase.name} onChange={e => updateCase(activeCase.id, { name: e.target.value })} style={{ flex: 1, background: "transparent", border: "none", color: C.text, fontSize: isMobile ? 15 : 18, fontWeight: 700, fontFamily: font, outline: "none", minWidth: 0 }} placeholder="æ¡ˆä»¶å" />
            {!isMobile && <button onClick={() => duplicateCase(activeCase)} style={{ ...topBtnStyle, color: C.gray, fontSize: 13, display: "flex", alignItems: "center", gap: 4 }}>â§‰ è¤‡è£½</button>}
            <button onClick={() => requestDelete(activeCase.id)} style={{ ...topBtnStyle, background: C.gray, color: C.white, fontSize: isMobile ? 16 : 18, padding: isMobile ? "6px 10px" : "8px 12px", borderColor: "transparent" }}>ğŸ—‘</button>
          </>)}
        </div>
        <div style={{ flex: 1, overflowY: "auto", padding: isMobile ? "12px 12px 32px" : "20px 24px 40px" }}>
          {activeCase ? <CaseDetail c={activeCase} update={(patch) => updateCase(activeCase.id, patch)} onDelete={() => requestDelete(activeCase.id)} />
            : <div style={{ display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100%", color: C.text3 }}>
                <div style={{ fontSize: 48, marginBottom: 16, opacity: 0.3 }}>ğŸ¢</div>
                <div style={{ fontSize: 16 }}>{isMobile ? "â˜° ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰æ¡ˆä»¶ã‚’é¸æŠãƒ»ä½œæˆ" : "å·¦ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰æ¡ˆä»¶ã‚’é¸æŠã€ã¾ãŸã¯æ–°è¦ä½œæˆã—ã¦ãã ã•ã„"}</div>
              </div>}
        </div>
      </div>

      {/* Delete dialog */}
      {deleteConfirmId && (
        <div style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.6)", display: "flex", alignItems: "center", justifyContent: "center", zIndex: 1000 }} onClick={cancelDelete}>
          <div style={{ background: C.surface, border: "1px solid " + C.border, borderRadius: 14, padding: "28px 32px", maxWidth: 360, width: "90%", textAlign: "center" }} onClick={e => e.stopPropagation()}>
            <div style={{ fontSize: 16, fontWeight: 700, color: C.text, marginBottom: 8 }}>æ¡ˆä»¶ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ</div>
            <div style={{ fontSize: 13, color: C.text2, marginBottom: 24 }}>ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚</div>
            <div style={{ display: "flex", gap: 10 }}>
              <button onClick={cancelDelete} style={{ flex: 1, padding: "10px 0", background: C.surface2, color: C.text, border: "1px solid " + C.border, borderRadius: 8, fontWeight: 600, fontSize: 14, cursor: "pointer" }}>ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
              <button onClick={confirmDelete} style={{ flex: 1, padding: "10px 0", background: C.red, color: C.white, border: "none", borderRadius: 8, fontWeight: 600, fontSize: 14, cursor: "pointer" }}>å‰Šé™¤ã™ã‚‹</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// â”€â”€â”€ CaseDetail â”€â”€â”€
function CaseDetail({ c, update, onDelete }) {
  const [expr, setExpr] = useState("");
  const [memo, setMemo] = useState("");
  const [error, setError] = useState("");
  const inputRef = useRef(null);
  const [dragIdx, setDragIdx] = useState(null);
  const [dragOverIdx, setDragOverIdx] = useState(null);

  const handleDragStart = (idx) => { setDragIdx(idx); };
  const handleDragOver = (e, idx) => { e.preventDefault(); setDragOverIdx(idx); };
  const handleDragEnd = () => {
    if (dragIdx !== null && dragOverIdx !== null && dragIdx !== dragOverIdx) {
      const ne = [...c.entries]; const [moved] = ne.splice(dragIdx, 1); ne.splice(dragOverIdx, 0, moved); update({ entries: ne });
    }
    setDragIdx(null); setDragOverIdx(null);
  };

  const addEntry = () => {
    try {
      const result = evaluate(expr);
      update({ entries: [...c.entries, { id: uid(), type: "calc", expr, memo, result }] });
      setExpr(""); setMemo(""); setError("");
    } catch (e) { setError(e.message); }
    inputRef.current?.focus();
  };

  const removeEntry = (eid) => { update({ entries: c.entries.filter(e => e.id !== eid) }); };
  const updateEntryMemo = (eid, v) => { update({ entries: c.entries.map(e => e.id === eid ? { ...e, memo: v } : e) }); };
  const updateEntryExpr = (eid, v) => {
    let r; try { r = evaluate(v); } catch { r = null; }
    update({ entries: c.entries.map(e => e.id === eid ? { ...e, expr: v, result: r !== null ? r : e.result } : e) });
  };

  const addFile = (e) => {
    const fl = e.target.files; if (!fl) return;
    Array.from(fl).forEach(file => {
      const reader = new FileReader();
      reader.onload = (ev) => { update({ files: [...c.files, { id: uid(), name: file.name, type: file.type, size: file.size, dataUrl: ev.target.result }] }); };
      reader.readAsDataURL(file);
    });
    e.target.value = "";
  };
  const removeFile = (fid) => { update({ files: c.files.filter(f => f.id !== fid) }); };

  const preview = (() => {
    if (!expr.trim()) return null;
    try { return { ok: true, value: evaluate(expr) }; } catch (e) { return { ok: false, message: e.message }; }
  })();

  const handleKeyDown = (e) => { if (e.key === "Enter" && expr.trim() && preview?.ok) { e.preventDefault(); addEntry(); } };

  return (
    <div style={{ maxWidth: 860, margin: "0 auto" }}>
      <div style={{ marginBottom: 24 }}>
        <textarea value={c.memo} onChange={e => update({ memo: e.target.value })} placeholder="æ¡ˆä»¶ãƒ¡ãƒ¢ï¼ˆæ‰€åœ¨åœ°ã€ç‰©ä»¶æ¦‚è¦ãªã©è‡ªç”±ã«è¨˜å…¥ï¼‰" rows={2}
          style={{ width: "100%", background: C.surface, border: "1px solid " + C.border, borderRadius: 8, padding: "10px 14px", color: C.text, fontSize: 13, fontFamily: font, resize: "vertical", outline: "none", boxSizing: "border-box" }} />
      </div>

      <div style={{ background: C.surface, border: "1px solid " + C.border, borderRadius: 12, padding: 16, marginBottom: 20 }}>
        <div style={{ display: "flex", flexDirection: "column", gap: 8, marginBottom: 8 }}>
          <input ref={inputRef} value={memo} onChange={e => setMemo(e.target.value)} placeholder="ãƒ¡ãƒ¢ï¼ˆä¾‹ï¼šå®¶è³ƒåå…¥ï¼‰"
            style={{ width: "100%", background: C.surface2, border: "1px solid " + C.border, borderRadius: 6, padding: "8px 12px", color: C.text, fontSize: 13, fontFamily: font, outline: "none", boxSizing: "border-box" }} />
          <div style={{ display: "flex", gap: 8 }}>
            <input value={expr} onChange={e => { setExpr(e.target.value); setError(""); }} onKeyDown={handleKeyDown} placeholder="è¨ˆç®—å¼ã‚’å…¥åŠ›ï¼ˆä¾‹ï¼š1500000 * 12ï¼‰"
              style={{ flex: 1, background: C.surface2, border: "1px solid " + (error ? C.red : C.border), borderRadius: 6, padding: "8px 14px", color: C.text, fontSize: 15, fontFamily: "'JetBrains Mono', monospace", outline: "none", boxSizing: "border-box" }} />
            <button onClick={addEntry} disabled={!expr.trim()} style={{ background: C.accent, color: C.white, border: "none", borderRadius: 6, padding: "8px 18px", fontWeight: 600, fontSize: 14, cursor: expr.trim() ? "pointer" : "default", opacity: expr.trim() ? 1 : 0.4, whiteSpace: "nowrap" }}>ï¼‹ è¿½åŠ </button>
          </div>
        </div>
        {expr.trim() && (
          <div style={{ marginTop: 8, padding: "10px 16px", background: preview?.ok ? C.surface2 : C.redSoft, borderRadius: 8, display: "flex", alignItems: "center", justifyContent: "space-between" }}>
            <span style={{ fontFamily: "'JetBrains Mono', monospace", fontSize: 13, color: C.text3 }}>{expr}</span>
            {preview?.ok
              ? <span style={{ fontFamily: "'JetBrains Mono', monospace", fontSize: 20, fontWeight: 700, color: preview.value >= 0 ? C.green : C.red }}>= {preview.value < 0 ? "â–³ " : ""}{formatNumber(Math.abs(preview.value))}</span>
              : <span style={{ fontSize: 12, color: C.red }}>{preview?.message}</span>}
          </div>
        )}
        {error && <div style={{ color: C.red, fontSize: 12, marginTop: 4 }}>{error}</div>}
      </div>

      {c.entries.length > 0 && (
        <div style={{ background: C.surface, border: "1px solid " + C.border, borderRadius: 12, overflow: "hidden", marginBottom: 24 }}>
          {c.entries.map((e, i) => {
            const isDragging = dragIdx === i;
            const isDragOver = dragOverIdx === i;
            return (
              <div key={e.id} draggable onDragStart={() => handleDragStart(i)} onDragOver={(ev) => handleDragOver(ev, i)} onDragEnd={handleDragEnd}
                style={{ padding: "12px 16px", borderBottom: i < c.entries.length - 1 ? "1px solid " + C.border : "none", background: isDragging ? C.surface2 : "transparent", borderTop: isDragOver ? "2px solid " + C.accent : "none", opacity: isDragging ? 0.5 : 1, display: "flex", gap: 10, alignItems: "stretch" }}>
                <div style={{ display: "flex", alignItems: "center", cursor: "grab", color: C.text3, fontSize: 16, userSelect: "none", padding: "0 2px", flexShrink: 0 }}>â ¿</div>
                <div style={{ flex: 1, minWidth: 0 }}>
                  <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 4 }}>
                    <input value={e.memo} onChange={ev => updateEntryMemo(e.id, ev.target.value)} style={{ background: "transparent", border: "none", color: C.text, fontSize: 13, fontWeight: 500, fontFamily: font, outline: "none", flex: 1 }} placeholder="ãƒ¡ãƒ¢ãªã—" />
                    <button onClick={() => removeEntry(e.id)} style={{ background: C.grayBg, border: "none", color: C.white, cursor: "pointer", fontSize: 11, fontWeight: 600, padding: "4px 10px", borderRadius: 6, flexShrink: 0 }}>å‰Šé™¤</button>
                  </div>
                  <div style={{ display: "flex", alignItems: "baseline", justifyContent: "space-between", gap: 12 }}>
                    <input value={e.expr} onChange={ev => updateEntryExpr(e.id, ev.target.value)}
                      style={{ fontFamily: "'JetBrains Mono', monospace", fontSize: 13, color: C.text2, background: "transparent", border: "none", borderBottom: "1px dashed " + C.border, outline: "none", flex: 1, minWidth: 0, padding: "2px 0" }} />
                    <div style={{ fontFamily: "'JetBrains Mono', monospace", fontSize: 18, fontWeight: 700, flexShrink: 0, whiteSpace: "nowrap", color: e.result >= 0 ? C.green : C.red }}>
                      = {e.result < 0 ? "â–³ " : ""}{formatNumber(Math.abs(e.result))}
                    </div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      )}

      {/* File attachments */}
      <div style={{ background: C.surface, border: "1px solid " + C.border, borderRadius: 12, padding: 16 }}>
        <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 12 }}>
          <div style={{ fontSize: 14, fontWeight: 600, color: C.text2 }}>ğŸ“ æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«</div>
          <label style={{ background: C.surface2, border: "1px solid " + C.border, borderRadius: 6, padding: "6px 14px", fontSize: 13, color: C.text, cursor: "pointer" }}>
            ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ 
            <input type="file" multiple onChange={addFile} style={{ display: "none" }} />
          </label>
        </div>
        {c.files.length === 0 && <div style={{ color: C.text3, fontSize: 13, textAlign: "center", padding: "16px 0" }}>æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“</div>}
        <div style={{ display: "flex", flexWrap: "wrap", gap: 8 }}>
          {c.files.map(f => (
            <div key={f.id} style={{ background: C.surface2, border: "1px solid " + C.border, borderRadius: 8, padding: "8px 12px", display: "flex", alignItems: "center", gap: 8, maxWidth: 260 }}>
              {f.type.startsWith("image/")
                ? <img src={f.dataUrl} alt={f.name} style={{ width: 36, height: 36, objectFit: "cover", borderRadius: 4 }} />
                : <div style={{ width: 36, height: 36, borderRadius: 4, background: C.accentSoft, display: "flex", alignItems: "center", justifyContent: "center", fontSize: 16 }}>{f.type.includes("pdf") ? "ğŸ“„" : "ğŸ“"}</div>}
              <div style={{ flex: 1, minWidth: 0 }}>
                <div style={{ fontSize: 12, fontWeight: 500, color: C.text, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{f.name}</div>
                <div style={{ fontSize: 10, color: C.text3 }}>{(f.size / 1024).toFixed(0)} KB</div>
              </div>
              <button onClick={() => removeFile(f.id)} style={{ background: "none", border: "none", color: C.text3, cursor: "pointer", fontSize: 12 }}>âœ•</button>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
</body>
</html>
